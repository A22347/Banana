char _STRC5FB_0EXD[] = "Licensee";
char _STRDA69_1EXD[] = "Covered Code";
char _STR9794_2EXD[] = "Original Intel Code";
char _STR7A4A_3EXD[] = "AS IS,";
char _STRA8FA_4EXD[] = "NO WARRANTY";
char _STR8E01_5EXD[] = "Disclaimer";
char _STR9D42_6EXD[] = "AS IS";
char _STR42AE_7EXD[] = "GPL";
char _STRC118_8EXD[] = "Length";
char _STR4ECE_9EXD[] = "Pointer";
char _STRA1CF_AEXD[] = "Parent Node";
char _STR4D2C_BEXD[] = "Sync Level";
char _STR1E55_CEXD[] = "Flags";
char _STR44A8_DEXD[] = "Parent Node";
char _STR607_EEXD[] = "Length";
char _STR1190_FEXD[] = "Handler";
char _STRFBD_10EXD[] = "System Notify";
char _STRFAED_11EXD[] = "Device Notify";
char _STR25C3_12EXD[] = "Handler";
char _STRAE1_13EXD[] = "Length";
char _STREF42_14EXD[] = "Address";
char _STRB33_15EXD[] = "System Notify";
char _STR9E39_16EXD[] = "Device Notify";
char _STR10DE_17EXD[] = "Handler";
char _STR350A_18EXD[] = "System Notify";
char _STR7A35_19EXD[] = "Device Notify";
char _STR2C7D_1AEXD[] = "Handler";
char _STRD21F_1BEXD[] = "Value";
char _STR966C_1CEXD[] = "Region Object";
char _STR5BCA_1DEXD[] = "Value";
char _STR7E6D_1EEXD[] = "Value";
char _STR119C_1FEXD[] = "Space Id";
char _STRFA9C_20EXD[] = "Next";
char _STR1F87_21EXD[] = "Node";
char _STR6344_22EXD[] = "Node";
char _STR4F12_23EXD[] = "Handler";
char _STR27A_24EXD[] = "Context";
char _STR711_25EXD[] = "Aml Start";
char _STR1B9D_26EXD[] = "Aml Length";
char _STRCC70_27EXD[] = "Handler";
char _STR6458_28EXD[] = "Flags";
char _STR1E31_29EXD[] = "Parent Node";
char _STR7A9A_2AEXD[] = "Flags";
char _STR3F98_2BEXD[] = "Owner Id";
char _STRF707_2CEXD[] = "Object List";
char _STR9908_2DEXD[] = "ExDumpObject: Display not implemented for object type %s\n";
char _STRF328_2EEXD[] = "%20s : %2.2X [%s]\n";
char _STRD496_2FEXD[] = "Type";
char _STR2031_30EXD[] = "%20s : %2.2X\n";
char _STRB33F_31EXD[] = "%20s : %4.4X\n";
char _STR4D81_32EXD[] = "%20s : %8.8X\n";
char _STRD83A_33EXD[] = "%20s : %8.8X%8.8X\n";
char _STR845D_34EXD[] = "Value";
char _STRB5A7_35EXD[] = "\n";
char _STRACFC_36EXD[] = "\nPackage Contents:\n";
char _STRAB51_37EXD[] = "Class Name";
char _STR3A67_38EXD[] = "%20s : %p ";
char _STR2D1_39EXD[] = "%s (Type %2.2X)";
char _STRB72_3AEXD[] = "->%p(%s %2.2X)";
char _STR3F0C_3BEXD[] = "\n**** Error: Object list appears to be circular linked";
char _STRFE98_3CEXD[] = "- No attached objects";
char _STR9110_3DEXD[] = "\n";
char _STRDA11_3EEXD[] = "%20s : %p";
char _STR9092_3FEXD[] = "(%s %2.2X)";
char _STRF0CE_40EXD[] = "->%p(%s %2.2X)";
char _STRA72B_41EXD[] = "\n**** Error: Handler list appears to be circular linked";
char _STR6F6_42EXD[] = "\n";
char _STR2D80_43EXD[] = "%20s : %p";
char _STR5ACF_44EXD[] = "(%s %2.2X)";
char _STR476E_45EXD[] = "->%p(%s %2.2X)";
char _STR2F64_46EXD[] = "\n**** Error: Region list appears to be circular linked";
char _STR6BF_47EXD[] = "\n";
char _STRFD5E_48EXD[] = "%20s : %p";
char _STR47CA_49EXD[] = " [%4.4s]";
char _STRB252_4AEXD[] = "\n";
char _STR1656_4BEXD[] = "**** Invalid table opcode [%X] ****\n";
char _STR1E43_4CEXD[] = "Null Object Descriptor\n";
char _STR3A39_4DEXD[] = "%p Namespace Node: ";
char _STR41C1_4EEXD[] = "%p is not a node or operand object: [%s]\n";
char _STRB84_4FEXD[] = "%*s[%u] %p Refs=%u ";
char _STRD3F_50EXD[] = " ";
char _STR3127_51EXD[] = "%p Refs=%u ";
char _STRAC9D_52EXD[] = "Reference: [%s] ";
char _STR691E_53EXD[] = "\n";
char _STR34D2_54EXD[] = "%p\n";
char _STRE_55EXD[] = "Table Index %X\n";
char _STR9323_56EXD[] = "%p [%s]\n";
char _STR916E_57EXD[] = "- [%4.4s] (Node %p)\n";
char _STRBC68_58EXD[] = "%X\n";
char _STRB935_59EXD[] = "%2.2X\n";
char _STR6FAA_5AEXD[] = "Buffer length %.2X @ %p\n";
char _STR7BCF_5BEXD[] = "Buffer Contents: (displaying length 0x%.2X)\n";
char _STR2F12_5CEXD[] = "Integer %8.8X%8.8X\n";
char _STR18AF_5DEXD[] = "Package [Len %X] ElementArray %p\n";
char _STR3A6_5EEXD[] = "Region %s (%X)";
char _STR940_5FEXD[] = "\n";
char _STR606B_60EXD[] = " base %8.8X%8.8X Length %X\n";
char _STR717A_61EXD[] = "String length %X @ %p ";
char _STR2C_62EXD[] = "\n";
char _STRB1D7_63EXD[] = "BankField\n";
char _STR8229_64EXD[] = "RegionField: Bits=%X AccWidth=%X Lock=%X Update=%X at byte=%X bit=%X of below:\n";
char _STRFF2D_65EXD[] = "IndexField\n";
char _STR6418_66EXD[] = "BufferField: %X bits at byte %X bit %X of\n";
char _STR49E5_67EXD[] = "*NULL*\n";
char _STR527A_68EXD[] = "*not a Buffer*\n";
char _STR122E_69EXD[] = "Event\n";
char _STRC673_6AEXD[] = "Method(%X) @ %p:%X\n";
char _STRD851_6BEXD[] = "Mutex\n";
char _STR7466_6CEXD[] = "Device\n";
char _STR705B_6DEXD[] = "Power\n";
char _STR5978_6EEXD[] = "Processor\n";
char _STR5BB9_6FEXD[] = "Thermal\n";
char _STRBA10_70EXD[] = "Unknown Type %X\n";
char _STR93B1_71EXD[] = "UNKNOWN";
char _STR4437_72EXD[] = "**** Start operand dump for opcode [%s], %u operands\n";
char _STRC0B_73EXD[] = "**** End operand dump for [%s]\n";
char _STR2954_74EXD[] = "%20s : %s\n";
char _STRBC87_75EXD[] = "%20s : %p\n";
char _STRC920_76EXD[] = "%20s : %4.4s\n";
char _STRD155_77EXD[] = "Name";
char _STR60C9_78EXD[] = "%20s : %2.2X [%s]\n";
char _STRDCA0_79EXD[] = "Type";
char _STRCD8F_7AEXD[] = " %p ";
char _STRD6A2_7BEXD[] = " Could not convert name to pathname: %s\n";
char _STR2F65_7CEXD[] = "%s: %s\n";
char _STR612F_7DEXD[] = "%22s %p";
char _STR4FD1_7EEXD[] = "Target :";
char _STR1D4E_7FEXD[] = " Table Index: %X\n";
char _STR5E62_80EXD[] = " [%s]\n";
char _STRA009_81EXD[] = " Target: %p\n";
char _STR8F93_82EXD[] = "  ";
char _STR5D3A_83EXD[] = "[%.2d] ";
char _STRD414_84EXD[] = "%p ";
char _STRC986_85EXD[] = "[Null Object]\n";
char _STR4993_86EXD[] = "[Integer] = %8.8X%8.8X\n";
char _STR8ECE_87EXD[] = "[String]  Value: ";
char _STRE004_88EXD[] = "\n";
char _STRCDB4_89EXD[] = "[Buffer] Length %.2X = ";
char _STRE1F2_8AEXD[] = "\n";
char _STRDDF2_8BEXD[] = "[Package] Contains %u Elements:\n";
char _STR9390_8CEXD[] = "[Object Reference] Class [%s]";
char _STRDCDD_8DEXD[] = "[%s] Type: %2.2X\n";
char _STRCA2D_8EEXD[] = "\nAttached Object %p";
char _STREDA_8FEXD[] = " - Namespace Node";
char _STRDEF3_90EXD[] = ":\n";
char _STRB3CA_91EXD[] = "%p is not an ACPI operand object: [%s]\n";
char _STR8F18_92EXD[] = "Not a known object type: %2.2X\n";
char _STR5497_93EXD[] = "Secondary object is not a known object type: %2.2X\n";
char _STRBEEF_94EXD[] = "\nExtra attached Object (%p):\n";

/******************************************************************************
 *
 * Module Name: exdump - Interpreter debug output routines
 *
 *****************************************************************************/

/******************************************************************************
 *
 * 1. Copyright Notice
 *
 * Some or all of this work - Copyright (c) 1999 - 2019, Intel Corp.
 * All rights reserved.
 *
 * 2. License
 *
 * 2.1. This is your license from Intel Corp. under its intellectual property
 * rights. You may have additional license terms from the party that provided
 * you this software, covering your right to use that party's intellectual
 * property rights.
 *
 * 2.2. Intel grants, free of charge, to any person (_STRC5FB_0EXD) obtaining a
 * copy of the source code appearing in this file (_STRDA69_1EXD) an
 * irrevocable, perpetual, worldwide license under Intel's copyrights in the
 * base code distributed originally by Intel (_STR9794_2EXD) to copy,
 * make derivatives, distribute, use and display any portion of the Covered
 * Code in any form, with the right to sublicense such rights; and
 *
 * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent
 * license (with the right to sublicense), under only those claims of Intel
 * patents that are infringed by the Original Intel Code, to make, use, sell,
 * offer to sell, and import the Covered Code and derivative works thereof
 * solely to the minimum extent necessary to exercise the above copyright
 * license, and in no event shall the patent license extend to any additions
 * to or modifications of the Original Intel Code. No other license or right
 * is granted directly or by implication, estoppel or otherwise;
 *
 * The above copyright and patent license is granted only if the following
 * conditions are met:
 *
 * 3. Conditions
 *
 * 3.1. Redistribution of Source with Rights to Further Distribute Source.
 * Redistribution of source code of any substantial portion of the Covered
 * Code or modification with rights to further distribute source must include
 * the above Copyright Notice, the above License, this list of Conditions,
 * and the following Disclaimer and Export Compliance provision. In addition,
 * Licensee must cause all Covered Code to which Licensee contributes to
 * contain a file documenting the changes Licensee made to create that Covered
 * Code and the date of any change. Licensee must include in that file the
 * documentation of any changes made by any predecessor Licensee. Licensee
 * must include a prominent statement that the modification is derived,
 * directly or indirectly, from Original Intel Code.
 *
 * 3.2. Redistribution of Source with no Rights to Further Distribute Source.
 * Redistribution of source code of any substantial portion of the Covered
 * Code or modification without rights to further distribute source must
 * include the following Disclaimer and Export Compliance provision in the
 * documentation and/or other materials provided with distribution. In
 * addition, Licensee may not authorize further sublicense of source of any
 * portion of the Covered Code, and must include terms to the effect that the
 * license from Licensee to its licensee is limited to the intellectual
 * property embodied in the software Licensee provides to its licensee, and
 * not to intellectual property embodied in modifications its licensee may
 * make.
 *
 * 3.3. Redistribution of Executable. Redistribution in executable form of any
 * substantial portion of the Covered Code or modification must reproduce the
 * above Copyright Notice, and the following Disclaimer and Export Compliance
 * provision in the documentation and/or other materials provided with the
 * distribution.
 *
 * 3.4. Intel retains all right, title, and interest in and to the Original
 * Intel Code.
 *
 * 3.5. Neither the name Intel nor any other trademark owned or controlled by
 * Intel shall be used in advertising or otherwise to promote the sale, use or
 * other dealings in products derived from or relating to the Covered Code
 * without prior written authorization from Intel.
 *
 * 4. Disclaimer and Export Compliance
 *
 * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED
 * HERE. ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE
 * IS PROVIDED _STR7A4A_3EXD AND INTEL WILL NOT PROVIDE ANY SUPPORT, ASSISTANCE,
 * INSTALLATION, TRAINING OR OTHER SERVICES. INTEL WILL NOT PROVIDE ANY
 * UPDATES, ENHANCEMENTS OR EXTENSIONS. INTEL SPECIFICALLY DISCLAIMS ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A
 * PARTICULAR PURPOSE.
 *
 * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES
 * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR
 * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY
 * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL
 * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES. THESE LIMITATIONS
 * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY
 * LIMITED REMEDY.
 *
 * 4.3. Licensee shall not export, either directly or indirectly, any of this
 * software or system incorporating such software without first obtaining any
 * required license or other approval from the U. S. Department of Commerce or
 * any other agency or department of the United States Government. In the
 * event Licensee exports any such software from the United States or
 * re-exports any such software from a foreign destination, Licensee shall
 * ensure that the distribution and export/re-export of the software is in
 * compliance with all laws, regulations, orders, or other restrictions of the
 * U.S. Export Administration Regulations. Licensee agrees that neither it nor
 * any of its subsidiaries will export/re-export any technical data, process,
 * software, or service, directly or indirectly, to any country for which the
 * United States government or any agency thereof requires an export license,
 * other governmental approval, or letter of assurance, without first obtaining
 * such license, approval or letter.
 *
 *****************************************************************************
 *
 * Alternatively, you may choose to be licensed under the terms of the
 * following license:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the _STRA8FA_4EXD disclaimer below
 *    (_STR8E01_5EXD) and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * _STR9D42_6EXD AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Alternatively, you may choose to be licensed under the terms of the
 * GNU General Public License (_STR42AE_7EXD) version 2 as published by the Free
 * Software Foundation.
 *
 *****************************************************************************/

#include "acpi.h"
#include "accommon.h"
#include "acinterp.h"
#include "amlcode.h"
#include "acnamesp.h"


#define _COMPONENT          ACPI_EXECUTER
        ACPI_MODULE_NAME    ("exdump")

/*
 * The following routines are used for debug output only
 */
#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)

/* Local prototypes */

void
AcpiExOutString (
    const char              *Title,
    const char              *Value);

void
AcpiExOutPointer (
    const char              *Title,
    const void              *Value);

void
AcpiExDumpObject (
    ACPI_OPERAND_OBJECT     *ObjDesc,
    ACPI_EXDUMP_INFO        *Info);

void
AcpiExDumpReferenceObj (
    ACPI_OPERAND_OBJECT     *ObjDesc);

void
AcpiExDumpPackageObj (
    ACPI_OPERAND_OBJECT     *ObjDesc,
    UINT32                  Level,
    UINT32                  Index);


/*******************************************************************************
 *
 * Object Descriptor info tables
 *
 * Note: The first table entry must be an INIT opcode and must contain
 * the table length (number of table entries)
 *
 ******************************************************************************/

ACPI_EXDUMP_INFO     AcpiExDumpInteger[2] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpInteger),        NULL},
    {ACPI_EXD_UINT64,   ACPI_EXD_OFFSET (Integer.Value),                _STRD21F_1BEXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpString[4] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpString),         NULL},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (String.Length),                _STRC118_8EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (String.Pointer),               _STR4ECE_9EXD},
    {ACPI_EXD_STRING,   0,                                              NULL}
};

ACPI_EXDUMP_INFO     AcpiExDumpBuffer[5] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpBuffer),         NULL},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Buffer.Length),                _STRC118_8EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Buffer.Pointer),               _STR4ECE_9EXD},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Buffer.Node),                  _STRA1CF_AEXD},
    {ACPI_EXD_BUFFER,   0,                                              NULL}
};

ACPI_EXDUMP_INFO     AcpiExDumpPackage[6] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpPackage),        NULL},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Package.Node),                 _STRA1CF_AEXD},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Package.Flags),                _STR1E55_CEXD},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Package.Count),                "Element Count"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Package.Elements),             "Element List"},
    {ACPI_EXD_PACKAGE,  0,                                              NULL}
};

ACPI_EXDUMP_INFO     AcpiExDumpDevice[4] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpDevice),         NULL},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Device.NotifyList[0]),         _STRFBD_10EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Device.NotifyList[1]),         _STRFAED_11EXD},
    {ACPI_EXD_HDLR_LIST,ACPI_EXD_OFFSET (Device.Handler),               _STR1190_FEXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpEvent[2] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpEvent),          NULL},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Event.OsSemaphore),            "OsSemaphore"}
};

ACPI_EXDUMP_INFO     AcpiExDumpMethod[9] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpMethod),         NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.InfoFlags),             "Info Flags"},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.ParamCount),            "Parameter Count"},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.SyncLevel),             _STR4D2C_BEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Method.Mutex),                 "Mutex"},
    {ACPI_EXD_UINT16,   ACPI_EXD_OFFSET (Method.OwnerId),               _STR3F98_2BEXD},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.ThreadCount),           "Thread Count"},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Method.AmlLength),             _STR1B9D_26EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Method.AmlStart),              _STR711_25EXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpMutex[6] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpMutex),          NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Mutex.SyncLevel),              _STR4D2C_BEXD},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Mutex.OriginalSyncLevel),      "Original Sync Level"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Mutex.OwnerThread),            "Owner Thread"},
    {ACPI_EXD_UINT16,   ACPI_EXD_OFFSET (Mutex.AcquisitionDepth),       "Acquire Depth"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Mutex.OsMutex),                "OsMutex"}
};

ACPI_EXDUMP_INFO     AcpiExDumpRegion[8] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpRegion),         NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Region.SpaceId),               _STR119C_1FEXD},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Region.Flags),                 _STR1E55_CEXD},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Region.Node),                  _STRA1CF_AEXD},
    {ACPI_EXD_ADDRESS,  ACPI_EXD_OFFSET (Region.Address),               _STREF42_14EXD},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Region.Length),                _STRC118_8EXD},
    {ACPI_EXD_HDLR_LIST,ACPI_EXD_OFFSET (Region.Handler),               _STR1190_FEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Region.Next),                  _STRFA9C_20EXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpPower[6] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpPower),          NULL},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (PowerResource.SystemLevel),    "System Level"},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (PowerResource.ResourceOrder),  "Resource Order"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (PowerResource.NotifyList[0]),  _STRFBD_10EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (PowerResource.NotifyList[1]),  _STRFAED_11EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (PowerResource.Handler),        _STR1190_FEXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpProcessor[7] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpProcessor),      NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Processor.ProcId),             "Processor ID"},
    {ACPI_EXD_UINT8 ,   ACPI_EXD_OFFSET (Processor.Length),             _STRC118_8EXD},
    {ACPI_EXD_ADDRESS,  ACPI_EXD_OFFSET (Processor.Address),            _STREF42_14EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Processor.NotifyList[0]),      _STRFBD_10EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Processor.NotifyList[1]),      _STRFAED_11EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Processor.Handler),           _STR1190_FEXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpThermal[4] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpThermal),        NULL},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (ThermalZone.NotifyList[0]),    _STRFBD_10EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (ThermalZone.NotifyList[1]),    _STRFAED_11EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (ThermalZone.Handler),          _STR1190_FEXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpBufferField[3] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpBufferField),    NULL},
    {ACPI_EXD_FIELD,    0,                                              NULL},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (BufferField.BufferObj),        "Buffer Object"}
};

ACPI_EXDUMP_INFO     AcpiExDumpRegionField[5] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpRegionField),    NULL},
    {ACPI_EXD_FIELD,    0,                                              NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Field.AccessLength),           "AccessLength"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Field.RegionObj),              _STR966C_1CEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Field.ResourceBuffer),         "ResourceBuffer"}
};

ACPI_EXDUMP_INFO     AcpiExDumpBankField[5] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpBankField),      NULL},
    {ACPI_EXD_FIELD,    0,                                              NULL},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (BankField.Value),              _STRD21F_1BEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (BankField.RegionObj),          _STR966C_1CEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (BankField.BankObj),            "Bank Object"}
};

ACPI_EXDUMP_INFO     AcpiExDumpIndexField[5] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpBankField),      NULL},
    {ACPI_EXD_FIELD,    0,                                              NULL},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (IndexField.Value),             _STRD21F_1BEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (IndexField.IndexObj),          "Index Object"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (IndexField.DataObj),           "Data Object"}
};

ACPI_EXDUMP_INFO     AcpiExDumpReference[9] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpReference),       NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Reference.Class),              "Class"},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Reference.TargetType),         "Target Type"},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Reference.Value),              _STRD21F_1BEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Reference.Object),             "Object Desc"},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Reference.Node),               _STR1F87_21EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Reference.Where),              "Where"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Reference.IndexPointer),       "Index Pointer"},
    {ACPI_EXD_REFERENCE,0,                                              NULL}
};

ACPI_EXDUMP_INFO     AcpiExDumpAddressHandler[6] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpAddressHandler), NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (AddressSpace.SpaceId),         _STR119C_1FEXD},
    {ACPI_EXD_HDLR_LIST,ACPI_EXD_OFFSET (AddressSpace.Next),            _STRFA9C_20EXD},
    {ACPI_EXD_RGN_LIST, ACPI_EXD_OFFSET (AddressSpace.RegionList),      "Region List"},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (AddressSpace.Node),            _STR1F87_21EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (AddressSpace.Context),         _STR27A_24EXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpNotify[7] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpNotify),         NULL},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Notify.Node),                  _STR1F87_21EXD},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Notify.HandlerType),           "Handler Type"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Handler),               _STR1190_FEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Context),               _STR27A_24EXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Next[0]),               "Next System Notify"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Next[1]),               "Next Device Notify"}
};

ACPI_EXDUMP_INFO     AcpiExDumpExtra[6] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpExtra),          NULL},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Extra.Method_REG),             "_REG Method"},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Extra.ScopeNode),              "Scope Node"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Extra.RegionContext),          "Region Context"},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Extra.AmlStart),               _STR711_25EXD},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Extra.AmlLength),              _STR1B9D_26EXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpData[3] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpData),           NULL},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Data.Handler),                 _STR1190_FEXD},
    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Data.Pointer),                 "Raw Data"}
};

/* Miscellaneous tables */

ACPI_EXDUMP_INFO     AcpiExDumpCommon[5] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpCommon),         NULL},
    {ACPI_EXD_TYPE ,    0,                                              NULL},
    {ACPI_EXD_UINT16,   ACPI_EXD_OFFSET (Common.ReferenceCount),        "Reference Count"},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Common.Flags),                 _STR1E55_CEXD},
    {ACPI_EXD_LIST,     ACPI_EXD_OFFSET (Common.NextObject),            _STRF707_2CEXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpFieldCommon[7] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpFieldCommon),    NULL},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (CommonField.FieldFlags),       "Field Flags"},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (CommonField.AccessByteWidth),  "Access Byte Width"},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (CommonField.BitLength),        "Bit Length"},
    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (CommonField.StartFieldBitOffset),"Field Bit Offset"},
    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (CommonField.BaseByteOffset),   "Base Byte Offset"},
    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (CommonField.Node),             _STRA1CF_AEXD}
};

ACPI_EXDUMP_INFO     AcpiExDumpNode[7] =
{
    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpNode),           NULL},
    {ACPI_EXD_UINT16,   ACPI_EXD_NSOFFSET (Flags),                      _STR1E55_CEXD},
    {ACPI_EXD_UINT16,   ACPI_EXD_NSOFFSET (OwnerId),                    _STR3F98_2BEXD},
    {ACPI_EXD_LIST,     ACPI_EXD_NSOFFSET (Object),                     _STRF707_2CEXD},
    {ACPI_EXD_NODE,     ACPI_EXD_NSOFFSET (Parent),                     "Parent"},
    {ACPI_EXD_NODE,     ACPI_EXD_NSOFFSET (Child),                      "Child"},
    {ACPI_EXD_NODE,     ACPI_EXD_NSOFFSET (Peer),                       "Peer"}
};


/* Dispatch table, indexed by object type */

ACPI_EXDUMP_INFO     *AcpiExDumpInfo[] =
{
    NULL,
    AcpiExDumpInteger,
    AcpiExDumpString,
    AcpiExDumpBuffer,
    AcpiExDumpPackage,
    NULL,
    AcpiExDumpDevice,
    AcpiExDumpEvent,
    AcpiExDumpMethod,
    AcpiExDumpMutex,
    AcpiExDumpRegion,
    AcpiExDumpPower,
    AcpiExDumpProcessor,
    AcpiExDumpThermal,
    AcpiExDumpBufferField,
    NULL,
    NULL,
    AcpiExDumpRegionField,
    AcpiExDumpBankField,
    AcpiExDumpIndexField,
    AcpiExDumpReference,
    NULL,
    NULL,
    AcpiExDumpNotify,
    AcpiExDumpAddressHandler,
    NULL,
    NULL,
    NULL,
    AcpiExDumpExtra,
    AcpiExDumpData
};


/*******************************************************************************
 *
 * FUNCTION:    AcpiExDumpObject
 *
 * PARAMETERS:  ObjDesc             - Descriptor to dump
 *              Info                - Info table corresponding to this object
 *                                    type
 *
 * RETURN:      None
 *
 * DESCRIPTION: Walk the info table for this object
 *
 ******************************************************************************/

void
AcpiExDumpObject (
    ACPI_OPERAND_OBJECT     *ObjDesc,
    ACPI_EXDUMP_INFO        *Info)
{
    UINT8                   *Target;
    const char              *Name;
    UINT8                   Count;
    ACPI_OPERAND_OBJECT     *Start;
    ACPI_OPERAND_OBJECT     *Data = NULL;
    ACPI_OPERAND_OBJECT     *Next;
    ACPI_NAMESPACE_NODE     *Node;


    if (!Info)
    {
        AcpiOsPrintf (
            _STR9908_2DEXD,
            AcpiUtGetObjectTypeName (ObjDesc));
        return;
    }

    /* First table entry must contain the table length (# of table entries) */

    Count = Info->Offset;

    while (Count)
    {
        if (!ObjDesc)
        {
            return;
        }

        Target = ACPI_ADD_PTR (UINT8, ObjDesc, Info->Offset);
        Name = Info->Name;

        switch (Info->Opcode)
        {
        case ACPI_EXD_INIT:

            break;

        case ACPI_EXD_TYPE:

            AcpiOsPrintf (_STRF328_2EEXD, _STRD496_2FEXD,
                ObjDesc->Common.Type,
                AcpiUtGetObjectTypeName (ObjDesc));
            break;

        case ACPI_EXD_UINT8:

            AcpiOsPrintf (_STR2031_30EXD, Name, *Target);
            break;

        case ACPI_EXD_UINT16:

            AcpiOsPrintf (_STRB33F_31EXD, Name, ACPI_GET16 (Target));
            break;

        case ACPI_EXD_UINT32:

            AcpiOsPrintf (_STR4D81_32EXD, Name, ACPI_GET32 (Target));
            break;

        case ACPI_EXD_UINT64:

            AcpiOsPrintf (_STRD83A_33EXD, _STRD21F_1BEXD,
                ACPI_FORMAT_UINT64 (ACPI_GET64 (Target)));
            break;

        case ACPI_EXD_POINTER:
        case ACPI_EXD_ADDRESS:

            AcpiExOutPointer (Name, *ACPI_CAST_PTR (void *, Target));
            break;

        case ACPI_EXD_STRING:

            AcpiUtPrintString (ObjDesc->String.Pointer, ACPI_UINT8_MAX);
            AcpiOsPrintf (_STRB5A7_35EXD);
            break;

        case ACPI_EXD_BUFFER:

            ACPI_DUMP_BUFFER (
                ObjDesc->Buffer.Pointer, ObjDesc->Buffer.Length);
            break;

        case ACPI_EXD_PACKAGE:

            /* Dump the package contents */

            AcpiOsPrintf (_STRACFC_36EXD);
            AcpiExDumpPackageObj (ObjDesc, 0, 0);
            break;

        case ACPI_EXD_FIELD:

            AcpiExDumpObject (ObjDesc, AcpiExDumpFieldCommon);
            break;

        case ACPI_EXD_REFERENCE:

            AcpiExOutString (_STRAB51_37EXD, AcpiUtGetReferenceName (ObjDesc));
            AcpiExDumpReferenceObj (ObjDesc);
            break;

        case ACPI_EXD_LIST:

            Start = *ACPI_CAST_PTR (void *, Target);
            Next = Start;

            AcpiOsPrintf (_STR3A67_38EXD, Name, Next);
            if (Next)
            {
                AcpiOsPrintf (_STR2D1_39EXD,
                    AcpiUtGetObjectTypeName (Next), Next->Common.Type);

                while (Next->Common.NextObject)
                {
                    if ((Next->Common.Type == ACPI_TYPE_LOCAL_DATA) &&
                        !Data)
                    {
                        Data = Next;
                    }

                    Next = Next->Common.NextObject;
                    AcpiOsPrintf (_STRB72_3AEXD, Next,
                        AcpiUtGetObjectTypeName (Next), Next->Common.Type);

                    if ((Next == Start) || (Next == Data))
                    {
                        AcpiOsPrintf (
                            _STR3F0C_3BEXD);
                        break;
                    }
                }
            }
            else
            {
                AcpiOsPrintf (_STRFE98_3CEXD);
            }

            AcpiOsPrintf (_STRB5A7_35EXD);
            break;

        case ACPI_EXD_HDLR_LIST:

            Start = *ACPI_CAST_PTR (void *, Target);
            Next = Start;

            AcpiOsPrintf (_STRDA11_3EEXD, Name, Next);
            if (Next)
            {
                AcpiOsPrintf (_STR9092_3FEXD,
                    AcpiUtGetObjectTypeName (Next),
                    Next->AddressSpace.SpaceId);

                while (Next->AddressSpace.Next)
                {
                    if ((Next->Common.Type == ACPI_TYPE_LOCAL_DATA) &&
                        !Data)
                    {
                        Data = Next;
                    }

                    Next = Next->AddressSpace.Next;
                    AcpiOsPrintf (_STRB72_3AEXD, Next,
                        AcpiUtGetObjectTypeName (Next),
                        Next->AddressSpace.SpaceId);

                    if ((Next == Start) || (Next == Data))
                    {
                        AcpiOsPrintf (
                            _STRA72B_41EXD);
                        break;
                    }
                }
            }

            AcpiOsPrintf (_STRB5A7_35EXD);
            break;

        case ACPI_EXD_RGN_LIST:

            Start = *ACPI_CAST_PTR (void *, Target);
            Next = Start;

            AcpiOsPrintf (_STRDA11_3EEXD, Name, Next);
            if (Next)
            {
                AcpiOsPrintf (_STR9092_3FEXD,
                    AcpiUtGetObjectTypeName (Next), Next->Common.Type);

                while (Next->Region.Next)
                {
                    if ((Next->Common.Type == ACPI_TYPE_LOCAL_DATA) &&
                        !Data)
                    {
                        Data = Next;
                    }

                    Next = Next->Region.Next;
                    AcpiOsPrintf (_STRB72_3AEXD, Next,
                        AcpiUtGetObjectTypeName (Next), Next->Common.Type);

                    if ((Next == Start) || (Next == Data))
                    {
                        AcpiOsPrintf (
                            _STR2F64_46EXD);
                        break;
                    }
                }
            }

            AcpiOsPrintf (_STRB5A7_35EXD);
            break;

        case ACPI_EXD_NODE:

            Node = *ACPI_CAST_PTR (ACPI_NAMESPACE_NODE *, Target);

            AcpiOsPrintf (_STRDA11_3EEXD, Name, Node);
            if (Node)
            {
                AcpiOsPrintf (_STR47CA_49EXD, Node->Name.Ascii);
            }
            AcpiOsPrintf (_STRB5A7_35EXD);
            break;

        default:

            AcpiOsPrintf (_STR1656_4BEXD,
                Info->Opcode);
            return;
        }

        Info++;
        Count--;
    }
}


/*******************************************************************************
 *
 * FUNCTION:    AcpiExDumpOperand
 *
 * PARAMETERS:  *ObjDesc        - Pointer to entry to be dumped
 *              Depth           - Current nesting depth
 *
 * RETURN:      None
 *
 * DESCRIPTION: Dump an operand object
 *
 ******************************************************************************/

void
AcpiExDumpOperand (
    ACPI_OPERAND_OBJECT     *ObjDesc,
    UINT32                  Depth)
{
    UINT32                  Length;
    UINT32                  Index;


    ACPI_FUNCTION_NAME (ExDumpOperand);


    /* Check if debug output enabled */

    if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_EXEC, _COMPONENT))
    {
        return;
    }

    if (!ObjDesc)
    {
        /* This could be a null element of a package */

        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, _STR1E43_4CEXD));
        return;
    }

    if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_NAMED)
    {
        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, _STR3A39_4DEXD, ObjDesc));
        ACPI_DUMP_ENTRY (ObjDesc, ACPI_LV_EXEC);
        return;
    }

    if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) != ACPI_DESC_TYPE_OPERAND)
    {
        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
            _STR41C1_4EEXD,
            ObjDesc, AcpiUtGetDescriptorName (ObjDesc)));
        ACPI_DUMP_BUFFER (ObjDesc, sizeof (ACPI_OPERAND_OBJECT));
        return;
    }

    /* ObjDesc is a valid object */

    if (Depth > 0)
    {
        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, _STRB84_4FEXD,
            Depth, _STRD3F_50EXD, Depth, ObjDesc, ObjDesc->Common.ReferenceCount));
    }
    else
    {
        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, _STR3127_51EXD,
            ObjDesc, ObjDesc->Common.ReferenceCount));
    }

    /* Decode object type */

    switch (ObjDesc->Common.Type)
    {
    case ACPI_TYPE_LOCAL_REFERENCE:

        AcpiOsPrintf (_STRAC9D_52EXD,
            AcpiUtGetReferenceName (ObjDesc));

        switch (ObjDesc->Reference.Class)
        {
        case ACPI_REFCLASS_DEBUG:

            AcpiOsPrintf (_STRB5A7_35EXD);
            break;

        case ACPI_REFCLASS_INDEX:

            AcpiOsPrintf (_STR34D2_54EXD, ObjDesc->Reference.Object);
            break;

        case ACPI_REFCLASS_TABLE:

            AcpiOsPrintf (_STRE_55EXD, ObjDesc->Reference.Value);
            break;

        case ACPI_REFCLASS_REFOF:

            AcpiOsPrintf (_STR9323_56EXD, ObjDesc->Reference.Object,
                AcpiUtGetTypeName (((ACPI_OPERAND_OBJECT *)
                    ObjDesc->Reference.Object)->Common.Type));
            break;

        case ACPI_REFCLASS_NAME:

            AcpiUtRepairName (ObjDesc->Reference.Node->Name.Ascii);
            AcpiOsPrintf (_STR916E_57EXD,
                ObjDesc->Reference.Node->Name.Ascii,
                ObjDesc->Reference.Node);
            break;

        case ACPI_REFCLASS_ARG:
        case ACPI_REFCLASS_LOCAL:

            AcpiOsPrintf (_STRBC68_58EXD, ObjDesc->Reference.Value);
            break;

        default:    /* Unknown reference class */

            AcpiOsPrintf (_STRB935_59EXD, ObjDesc->Reference.Class);
            break;
        }
        break;

    case ACPI_TYPE_BUFFER:

        AcpiOsPrintf (_STR6FAA_5AEXD,
            ObjDesc->Buffer.Length, ObjDesc->Buffer.Pointer);

        /* Debug only -- dump the buffer contents */

        if (ObjDesc->Buffer.Pointer)
        {
            Length = ObjDesc->Buffer.Length;
            if (Length > 128)
            {
                Length = 128;
            }

            AcpiOsPrintf (
                _STR7BCF_5BEXD, Length);
            ACPI_DUMP_BUFFER (ObjDesc->Buffer.Pointer, Length);
        }
        break;

    case ACPI_TYPE_INTEGER:

        AcpiOsPrintf (_STR2F12_5CEXD,
            ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
        break;

    case ACPI_TYPE_PACKAGE:

        AcpiOsPrintf (_STR18AF_5DEXD,
            ObjDesc->Package.Count, ObjDesc->Package.Elements);

        /*
         * If elements exist, package element pointer is valid,
         * and debug_level exceeds 1, dump package's elements.
         */
        if (ObjDesc->Package.Count &&
            ObjDesc->Package.Elements &&
            AcpiDbgLevel > 1)
        {
            for (Index = 0; Index < ObjDesc->Package.Count; Index++)
            {
                AcpiExDumpOperand (
                    ObjDesc->Package.Elements[Index], Depth + 1);
            }
        }
        break;

    case ACPI_TYPE_REGION:

        AcpiOsPrintf (_STR3A6_5EEXD,
            AcpiUtGetRegionName (ObjDesc->Region.SpaceId),
            ObjDesc->Region.SpaceId);

        /*
         * If the address and length have not been evaluated,
         * don't print them.
         */
        if (!(ObjDesc->Region.Flags & AOPOBJ_DATA_VALID))
        {
            AcpiOsPrintf (_STRB5A7_35EXD);
        }
        else
        {
            AcpiOsPrintf (_STR606B_60EXD,
                ACPI_FORMAT_UINT64 (ObjDesc->Region.Address),
                ObjDesc->Region.Length);
        }
        break;

    case ACPI_TYPE_STRING:

        AcpiOsPrintf (_STR717A_61EXD,
            ObjDesc->String.Length,
            ObjDesc->String.Pointer);

        AcpiUtPrintString (ObjDesc->String.Pointer, ACPI_UINT8_MAX);
        AcpiOsPrintf (_STRB5A7_35EXD);
        break;

    case ACPI_TYPE_LOCAL_BANK_FIELD:

        AcpiOsPrintf (_STRB1D7_63EXD);
        break;

    case ACPI_TYPE_LOCAL_REGION_FIELD:

        AcpiOsPrintf (_STR8229_64EXD,
            ObjDesc->Field.BitLength,
            ObjDesc->Field.AccessByteWidth,
            ObjDesc->Field.FieldFlags & AML_FIELD_LOCK_RULE_MASK,
            ObjDesc->Field.FieldFlags & AML_FIELD_UPDATE_RULE_MASK,
            ObjDesc->Field.BaseByteOffset,
            ObjDesc->Field.StartFieldBitOffset);

        AcpiExDumpOperand (ObjDesc->Field.RegionObj, Depth + 1);
        break;

    case ACPI_TYPE_LOCAL_INDEX_FIELD:

        AcpiOsPrintf (_STRFF2D_65EXD);
        break;

    case ACPI_TYPE_BUFFER_FIELD:

        AcpiOsPrintf (_STR6418_66EXD,
            ObjDesc->BufferField.BitLength,
            ObjDesc->BufferField.BaseByteOffset,
            ObjDesc->BufferField.StartFieldBitOffset);

        if (!ObjDesc->BufferField.BufferObj)
        {
            ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, _STR49E5_67EXD));
        }
        else if ((ObjDesc->BufferField.BufferObj)->Common.Type !=
            ACPI_TYPE_BUFFER)
        {
            AcpiOsPrintf (_STR527A_68EXD);
        }
        else
        {
            AcpiExDumpOperand (ObjDesc->BufferField.BufferObj, Depth + 1);
        }
        break;

    case ACPI_TYPE_EVENT:

        AcpiOsPrintf (_STR122E_69EXD);
        break;

    case ACPI_TYPE_METHOD:

        AcpiOsPrintf (_STRC673_6AEXD,
            ObjDesc->Method.ParamCount,
            ObjDesc->Method.AmlStart,
            ObjDesc->Method.AmlLength);
        break;

    case ACPI_TYPE_MUTEX:

        AcpiOsPrintf (_STRD851_6BEXD);
        break;

    case ACPI_TYPE_DEVICE:

        AcpiOsPrintf (_STR7466_6CEXD);
        break;

    case ACPI_TYPE_POWER:

        AcpiOsPrintf (_STR705B_6DEXD);
        break;

    case ACPI_TYPE_PROCESSOR:

        AcpiOsPrintf (_STR5978_6EEXD);
        break;

    case ACPI_TYPE_THERMAL:

        AcpiOsPrintf (_STR5BB9_6FEXD);
        break;

    default:

        /* Unknown Type */

        AcpiOsPrintf (_STRBA10_70EXD, ObjDesc->Common.Type);
        break;
    }

    return;
}


/*******************************************************************************
 *
 * FUNCTION:    AcpiExDumpOperands
 *
 * PARAMETERS:  Operands            - A list of Operand objects
 *              OpcodeName          - AML opcode name
 *              NumOperands         - Operand count for this opcode
 *
 * DESCRIPTION: Dump the operands associated with the opcode
 *
 ******************************************************************************/

void
AcpiExDumpOperands (
    ACPI_OPERAND_OBJECT     **Operands,
    const char              *OpcodeName,
    UINT32                  NumOperands)
{
    ACPI_FUNCTION_TRACE (ExDumpOperands);


    if (!OpcodeName)
    {
        OpcodeName = _STR93B1_71EXD;
    }

    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
        _STR4437_72EXD,
        OpcodeName, NumOperands));

    if (NumOperands == 0)
    {
        NumOperands = 1;
    }

    /* Dump the individual operands */

    while (NumOperands)
    {
        AcpiExDumpOperand (*Operands, 0);
        Operands++;
        NumOperands--;
    }

    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
        _STRC0B_73EXD, OpcodeName));
    return_VOID;
}


/*******************************************************************************
 *
 * FUNCTION:    AcpiExOut* functions
 *
 * PARAMETERS:  Title               - Descriptive text
 *              Value               - Value to be displayed
 *
 * DESCRIPTION: Object dump output formatting functions. These functions
 *              reduce the number of format strings required and keeps them
 *              all in one place for easy modification.
 *
 ******************************************************************************/

void
AcpiExOutString (
    const char              *Title,
    const char              *Value)
{
    AcpiOsPrintf (_STR2954_74EXD, Title, Value);
}

void
AcpiExOutPointer (
    const char              *Title,
    const void              *Value)
{
    AcpiOsPrintf (_STRBC87_75EXD, Title, Value);
}


/*******************************************************************************
 *
 * FUNCTION:    AcpiExDumpNamespaceNode
 *
 * PARAMETERS:  Node                - Descriptor to dump
 *              Flags               - Force display if TRUE
 *
 * DESCRIPTION: Dumps the members of the given.Node
 *
 ******************************************************************************/

void
AcpiExDumpNamespaceNode (
    ACPI_NAMESPACE_NODE     *Node,
    UINT32                  Flags)
{

    ACPI_FUNCTION_ENTRY ();


    if (!Flags)
    {
        /* Check if debug output enabled */

        if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_OBJECTS, _COMPONENT))
        {
            return;
        }
    }

    AcpiOsPrintf (_STRC920_76EXD, _STRD155_77EXD, AcpiUtGetNodeName (Node));
    AcpiOsPrintf (_STRF328_2EEXD, _STRD496_2FEXD,
        Node->Type, AcpiUtGetTypeName (Node->Type));

    AcpiExDumpObject (ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Node),
        AcpiExDumpNode);
}


/*******************************************************************************
 *
 * FUNCTION:    AcpiExDumpReferenceObj
 *
 * PARAMETERS:  Object              - Descriptor to dump
 *
 * DESCRIPTION: Dumps a reference object
 *
 ******************************************************************************/

void
AcpiExDumpReferenceObj (
    ACPI_OPERAND_OBJECT     *ObjDesc)
{
    ACPI_BUFFER             RetBuf;
    ACPI_STATUS             Status;


    RetBuf.Length = ACPI_ALLOCATE_LOCAL_BUFFER;

    if (ObjDesc->Reference.Class == ACPI_REFCLASS_NAME)
    {
        AcpiOsPrintf (_STRCD8F_7AEXD, ObjDesc->Reference.Node);

        Status = AcpiNsHandleToPathname (ObjDesc->Reference.Node,
            &RetBuf, TRUE);
        if (ACPI_FAILURE (Status))
        {
            AcpiOsPrintf (_STRD6A2_7BEXD,
                AcpiFormatException (Status));
        }
        else
        {
            AcpiOsPrintf (_STR2F65_7CEXD,
                AcpiUtGetTypeName (ObjDesc->Reference.Node->Type),
                (char *) RetBuf.Pointer);
            ACPI_FREE (RetBuf.Pointer);
        }
    }
    else if (ObjDesc->Reference.Object)
    {
        if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_OPERAND)
        {
            AcpiOsPrintf (_STR612F_7DEXD, _STR4FD1_7EEXD,
                ObjDesc->Reference.Object);
            if (ObjDesc->Reference.Class == ACPI_REFCLASS_TABLE)
            {
                AcpiOsPrintf (_STR1D4E_7FEXD,
                    ObjDesc->Reference.Value);
            }
            else
            {
                AcpiOsPrintf (_STR5E62_80EXD,
                    AcpiUtGetTypeName (((ACPI_OPERAND_OBJECT *)
                    ObjDesc->Reference.Object)->Common.Type));
            }
        }
        else
        {
            AcpiOsPrintf (_STRA009_81EXD, ObjDesc->Reference.Object);
        }
    }
}


/*******************************************************************************
 *
 * FUNCTION:    AcpiExDumpPackageObj
 *
 * PARAMETERS:  ObjDesc             - Descriptor to dump
 *              Level               - Indentation Level
 *              Index               - Package index for this object
 *
 * DESCRIPTION: Dumps the elements of the package
 *
 ******************************************************************************/

void
AcpiExDumpPackageObj (
    ACPI_OPERAND_OBJECT     *ObjDesc,
    UINT32                  Level,
    UINT32                  Index)
{
    UINT32                  i;


    /* Indentation and index output */

    if (Level > 0)
    {
        for (i = 0; i < Level; i++)
        {
            AcpiOsPrintf (_STR8F93_82EXD);
        }

        AcpiOsPrintf (_STR5D3A_83EXD, Index);
    }

    AcpiOsPrintf (_STRD414_84EXD, ObjDesc);

    /* Null package elements are allowed */

    if (!ObjDesc)
    {
        AcpiOsPrintf (_STRC986_85EXD);
        return;
    }

    /* Packages may only contain a few object types */

    switch (ObjDesc->Common.Type)
    {
    case ACPI_TYPE_INTEGER:

        AcpiOsPrintf (_STR4993_86EXD,
            ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
        break;

    case ACPI_TYPE_STRING:

        AcpiOsPrintf (_STR8ECE_87EXD);
        AcpiUtPrintString (ObjDesc->String.Pointer, ACPI_UINT8_MAX);
        AcpiOsPrintf (_STRB5A7_35EXD);
        break;

    case ACPI_TYPE_BUFFER:

        AcpiOsPrintf (_STRCDB4_89EXD, ObjDesc->Buffer.Length);
        if (ObjDesc->Buffer.Length)
        {
            AcpiUtDebugDumpBuffer (
                ACPI_CAST_PTR (UINT8, ObjDesc->Buffer.Pointer),
                ObjDesc->Buffer.Length, DB_DWORD_DISPLAY, _COMPONENT);
        }
        else
        {
            AcpiOsPrintf (_STRB5A7_35EXD);
        }
        break;

    case ACPI_TYPE_PACKAGE:

        AcpiOsPrintf (_STRDDF2_8BEXD,
            ObjDesc->Package.Count);

        for (i = 0; i < ObjDesc->Package.Count; i++)
        {
            AcpiExDumpPackageObj (
                ObjDesc->Package.Elements[i], Level + 1, i);
        }
        break;

    case ACPI_TYPE_LOCAL_REFERENCE:

        AcpiOsPrintf (_STR9390_8CEXD,
            AcpiUtGetReferenceName (ObjDesc));
        AcpiExDumpReferenceObj (ObjDesc);
        break;

    default:

        AcpiOsPrintf (_STRDCDD_8DEXD,
            AcpiUtGetTypeName (ObjDesc->Common.Type), ObjDesc->Common.Type);
        break;
    }
}


/*******************************************************************************
 *
 * FUNCTION:    AcpiExDumpObjectDescriptor
 *
 * PARAMETERS:  ObjDesc             - Descriptor to dump
 *              Flags               - Force display if TRUE
 *
 * DESCRIPTION: Dumps the members of the object descriptor given.
 *
 ******************************************************************************/

void
AcpiExDumpObjectDescriptor (
    ACPI_OPERAND_OBJECT     *ObjDesc,
    UINT32                  Flags)
{
    ACPI_FUNCTION_TRACE (ExDumpObjectDescriptor);


    if (!ObjDesc)
    {
        return_VOID;
    }

    if (!Flags)
    {
        /* Check if debug output enabled */

        if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_OBJECTS, _COMPONENT))
        {
            return_VOID;
        }
    }

    if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_NAMED)
    {
        AcpiExDumpNamespaceNode ((ACPI_NAMESPACE_NODE *) ObjDesc, Flags);

        ObjDesc = ((ACPI_NAMESPACE_NODE *) ObjDesc)->Object;
        if (!ObjDesc)
        {
            return_VOID;
        }

        AcpiOsPrintf (_STRCA2D_8EEXD, ObjDesc);
        if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_NAMED)
        {
            AcpiOsPrintf (_STREDA_8FEXD);
        }

        AcpiOsPrintf (_STRDEF3_90EXD);
        goto DumpObject;
    }

    if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) != ACPI_DESC_TYPE_OPERAND)
    {
        AcpiOsPrintf (
            _STRB3CA_91EXD,
            ObjDesc, AcpiUtGetDescriptorName (ObjDesc));
        return_VOID;
    }

    /* Validate the object type */

    if (ObjDesc->Common.Type > ACPI_TYPE_LOCAL_MAX)
    {
        AcpiOsPrintf (_STR8F18_92EXD,
            ObjDesc->Common.Type);
        return_VOID;
    }


DumpObject:

    if (!ObjDesc)
    {
        return_VOID;
    }

    /* Common Fields */

    AcpiExDumpObject (ObjDesc, AcpiExDumpCommon);

    /* Object-specific fields */

    AcpiExDumpObject (ObjDesc, AcpiExDumpInfo[ObjDesc->Common.Type]);

    if (ObjDesc->Common.Type == ACPI_TYPE_REGION)
    {
        ObjDesc = ObjDesc->Common.NextObject;
        if (ObjDesc->Common.Type > ACPI_TYPE_LOCAL_MAX)
        {
            AcpiOsPrintf (
                _STR5497_93EXD,
                ObjDesc->Common.Type);

            return_VOID;
        }

        AcpiOsPrintf (_STRBEEF_94EXD, ObjDesc);
        AcpiExDumpObject (ObjDesc, AcpiExDumpInfo[ObjDesc->Common.Type]);
    }

    return_VOID;
}

#endif
